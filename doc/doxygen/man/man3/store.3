.TH "Datastore operations" 3 "Tue Mar 26 2013" "Version 0.4.0" "libnetconf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Datastore operations \- 
.PP
libnetconf's functions for handling NETCONF datastores\&.  

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBNCDS_INTERNAL_ID\fP   0"
.br
.RI "\fIDatastore ID to access libnetconf's internal datastores such as notifications, monitoring, etc\&. \fP"
.ti -1c
.RI "#define \fBNCDS_RPC_NOT_APPLICABLE\fP   ((void *) -1)"
.br
.RI "\fIReturn value of \fBncds_apply_rpc()\fP when the requested operation is not applicable to the specified datastore\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBncds_id\fP"
.br
.RI "\fIDatastore ID\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBNC_DATASTORE\fP { \fBNC_DATASTORE_ERROR\fP, \fBNC_DATASTORE_CONFIG\fP, \fBNC_DATASTORE_URL\fP, \fBNC_DATASTORE_RUNNING\fP, \fBNC_DATASTORE_STARTUP\fP, \fBNC_DATASTORE_CANDIDATE\fP }"
.br
.RI "\fIEnumeration of the supported types of datastores defined by NETCONF\&. \fP"
.ti -1c
.RI "enum \fBNCDS_TYPE\fP { \fBNCDS_TYPE_EMPTY\fP, \fBNCDS_TYPE_FILE\fP }"
.br
.RI "\fIDatastore implementation types provided by libnetconf\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct ncds_ds * \fBncds_new\fP (\fBNCDS_TYPE\fP type, const char *model_path, char *(*get_state)(const char *model, const char *running, struct nc_err **e))"
.br
.RI "\fICreate a new datastore structure of the specified implementation type\&. \fP"
.ti -1c
.RI "int \fBncds_file_set_path\fP (struct ncds_ds *datastore, const char *path)"
.br
.RI "\fIAssign the path of the datastore file into the datastore structure\&. \fP"
.ti -1c
.RI "\fBncds_id\fP \fBncds_init\fP (struct ncds_ds *datastore)"
.br
.RI "\fIActivate datastore structure for use\&. \fP"
.ti -1c
.RI "void \fBncds_free\fP (struct ncds_ds *datastore)"
.br
.RI "\fIClose the specified datastore and free all the resources\&. \fP"
.ti -1c
.RI "void \fBncds_free2\fP (\fBncds_id\fP datastore_id)"
.br
.RI "\fIClose specified datastore and free all the resources\&. \fP"
.ti -1c
.RI "\fBnc_reply\fP * \fBncds_apply_rpc\fP (\fBncds_id\fP id, const struct nc_session *session, const \fBnc_rpc\fP *rpc)"
.br
.RI "\fIPerform the requested RPC operation on the datastore\&. \fP"
.ti -1c
.RI "void \fBncds_break_locks\fP (const struct nc_session *session)"
.br
.RI "\fIRemove all the locks that the given session is holding\&. \fP"
.ti -1c
.RI "char * \fBncds_get_model\fP (\fBncds_id\fP id)"
.br
.RI "\fIReturn a serialized XML containing the data model in the YIN format\&. \fP"
.ti -1c
.RI "const char * \fBncds_get_model_path\fP (\fBncds_id\fP id)"
.br
.RI "\fIReturn path to the file containing the datastore datamodel\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
libnetconf's functions for handling NETCONF datastores\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define NCDS_INTERNAL_ID   0"

.PP
Datastore ID to access libnetconf's internal datastores such as notifications, monitoring, etc\&. 
.SS "#define NCDS_RPC_NOT_APPLICABLE   ((void *) -1)"

.PP
Return value of \fBncds_apply_rpc()\fP when the requested operation is not applicable to the specified datastore\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBncds_id\fP"

.PP
Datastore ID\&. Each datastore gets its ID after initialisation (\fBncds_init()\fP)\&. Only initialised datastores can be used to access the configuration data\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBNC_DATASTORE\fP"

.PP
Enumeration of the supported types of datastores defined by NETCONF\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINC_DATASTORE_ERROR \fP\fP
error state of functions returning the datastore type 
.TP
\fB\fINC_DATASTORE_CONFIG \fP\fP
value describing that the datastore is set as config 
.TP
\fB\fINC_DATASTORE_URL \fP\fP
value describing that the datastore data should be given from the URL 
.TP
\fB\fINC_DATASTORE_RUNNING \fP\fP
base NETCONF's datastore containing the current device configuration 
.TP
\fB\fINC_DATASTORE_STARTUP \fP\fP
separated startup datastore as defined in Distinct Startup Capability 
.TP
\fB\fINC_DATASTORE_CANDIDATE \fP\fP
separated working datastore as defined in Candidate Configuration Capability 
.SS "enum \fBNCDS_TYPE\fP"

.PP
Datastore implementation types provided by libnetconf\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINCDS_TYPE_EMPTY \fP\fP
No datastore\&. For read-only devices\&. 
.TP
\fB\fINCDS_TYPE_FILE \fP\fP
Datastores implemented as files 
.SH "Function Documentation"
.PP 
.SS "struct ncds_ds* ncds_new (\fBNCDS_TYPE\fPtype, const char *model_path, char *(*)(const char *model, const char *running, struct nc_err **e)get_state)\fC [read]\fP"

.PP
Create a new datastore structure of the specified implementation type\&. \fBParameters:\fP
.RS 4
\fItype\fP Datastore implementation type for the new datastore structure\&. 
.br
\fImodel_path\fP Path to the YIN configuration data model\&. 
.br
\fIget_state\fP Pointer to a callback function that returns a serialized XML document containing the state configuration data of the device\&. The parameters it receives are a serialized configuration data model in YIN format and the current content of the running datastore\&. If NULL is set, <get> operation is performed in the same way as <get-config>\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Prepared (not configured) datastore structure\&. To configure the structure, caller must use the parameter setters of the specific datastore implementation type\&. Then, the datastore can be initiated (\fBncds_init()\fP) and used to access the configuration data\&. 
.RE
.PP

.SS "int ncds_file_set_path (struct ncds_ds *datastore, const char *path)"

.PP
Assign the path of the datastore file into the datastore structure\&. Checks if the file exist and is accessible for reading and writing\&. If the file does not exist, it is created\&. The file is opened and the file descriptor is stored in the structure\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore structure to be configured\&. 
.br
\fIpath\fP File path to the file storing configuration datastores\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success -1 Invalid datastore -2 Invalid path ((does not exist && can not be created) || insufficient rights) 
.RE
.PP

.SS "\fBncds_id\fP ncds_init (struct ncds_ds *datastore)"

.PP
Activate datastore structure for use\&. The datastore configuration is checked and if everything is correct, datastore gets its unique ID to be used for datastore operations (\fBncds_apply_rpc()\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore to be initiated\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Positive integer with the datastore ID on success, negative value on error\&. -1 Invalid datastore -2 Type-specific initialization failed -3 Unsupported datastore type -4 Memory allocation problem 
.RE
.PP

.SS "void ncds_free (struct ncds_ds *datastore)"

.PP
Close the specified datastore and free all the resources\&. Equivalent function to \fBncds_free2()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore to be closed\&. 
.RE
.PP

.SS "void ncds_free2 (\fBncds_id\fPdatastore_id)"

.PP
Close specified datastore and free all the resources\&. Equivalent function to \fBncds_free()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore_id\fP ID of the datastore to be closed\&. 
.RE
.PP

.SS "\fBnc_reply\fP* ncds_apply_rpc (\fBncds_id\fPid, const struct nc_session *session, const \fBnc_rpc\fP *rpc)"

.PP
Perform the requested RPC operation on the datastore\&. \fBParameters:\fP
.RS 4
\fIid\fP Datastore ID\&. Use 0 to apply request (typically <get>) onto the libnetconf's internal datastore\&. 
.br
\fIsession\fP NETCONF session (a dummy session is acceptable) where the <rpc> came from\&. Capabilities checks are done according to this session\&. 
.br
\fIrpc\fP NETCONF <rpc> message specifying requested operation\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL in case of a non-NC_RPC_DATASTORE_* operation type, else <rpc-reply> with <ok>, <data> or <rpc-error> according to the type and the result of the requested operation\&. When the requested operation is not applicable to the specified datastore (e\&.g\&. the namespace does not match), NCDS_RPC_NOT_APPLICABLE ((void *) -1)) is returned\&. 
.RE
.PP

.SS "void ncds_break_locks (const struct nc_session *session)"

.PP
Remove all the locks that the given session is holding\&. \fBParameters:\fP
.RS 4
\fIsession\fP Session holding locks to remove 
.RE
.PP

.SS "char* ncds_get_model (\fBncds_id\fPid)"

.PP
Return a serialized XML containing the data model in the YIN format\&. \fBParameters:\fP
.RS 4
\fIid\fP ID of the datastore whose data model we want
.RE
.PP
\fBReturns:\fP
.RS 4
String containing YIN model\&. Caller must free the memory after use\&. 
.RE
.PP

.SS "const char* ncds_get_model_path (\fBncds_id\fPid)"

.PP
Return path to the file containing the datastore datamodel\&. \fBParameters:\fP
.RS 4
\fIid\fP ID of the datastore whose data model we want
.RE
.PP
\fBReturns:\fP
.RS 4
String containing the path to the file containing the datastore datamodel\&. The caller must NOT free the memory\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libnetconf from the source code\&.

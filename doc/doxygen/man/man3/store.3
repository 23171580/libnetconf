.TH "Datastore operations" 3 "Mon Sep 24 2012" "Version 0.1.4" "libnetconf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Datastore operations \- 
.PP
libnetconf's functions for handling NETCONF datastores\&.  

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBncds_id\fP"
.br
.RI "\fIDatastore ID\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBNC_DATASTORE\fP { \fBNC_DATASTORE_NONE\fP, \fBNC_DATASTORE_RUNNING\fP, \fBNC_DATASTORE_STARTUP\fP, \fBNC_DATASTORE_CANDIDATE\fP }"
.br
.RI "\fIEnumeration of supported types of datastores defined by NETCONF\&. \fP"
.ti -1c
.RI "enum \fBNCDS_TYPE\fP { \fBNCDS_TYPE_EMPTY\fP, \fBNCDS_TYPE_FILE\fP }"
.br
.RI "\fIDatastore implementation types provided by libnetconf\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct ncds_ds * \fBncds_new\fP (\fBNCDS_TYPE\fP type, const char *model_path, char *(*get_state)(const char *model, const char *running, struct nc_err **e))"
.br
.RI "\fICreate new datastore structure of the specified implementation type\&. \fP"
.ti -1c
.RI "int \fBncds_file_set_path\fP (struct ncds_ds *datastore, const char *path)"
.br
.RI "\fIAssign path of the datastore file into the datastore structure\&. \fP"
.ti -1c
.RI "\fBncds_id\fP \fBncds_init\fP (struct ncds_ds *datastore)"
.br
.RI "\fIActivate datastore structure for use\&. \fP"
.ti -1c
.RI "void \fBncds_free\fP (struct ncds_ds *datastore)"
.br
.RI "\fIClose specified datastore and free all resources\&. \fP"
.ti -1c
.RI "void \fBncds_free2\fP (\fBncds_id\fP datastore_id)"
.br
.RI "\fIClose specified datastore and free all resources\&. \fP"
.ti -1c
.RI "\fBnc_reply\fP * \fBncds_apply_rpc\fP (\fBncds_id\fP id, const struct nc_session *session, const \fBnc_rpc\fP *rpc)"
.br
.RI "\fIPerform requested RPC operation on the datastore\&. \fP"
.ti -1c
.RI "void \fBncds_break_locks\fP (const struct nc_session *session)"
.br
.RI "\fIRemove all locks that is holding given session\&. \fP"
.ti -1c
.RI "char * \fBncds_get_model\fP (\fBncds_id\fP id)"
.br
.RI "\fIReturn serialized XML containing data model in YIN format\&. \fP"
.ti -1c
.RI "const char * \fBncds_get_model_path\fP (\fBncds_id\fP id)"
.br
.RI "\fIReturn path to file containing datastore datamodel\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
libnetconf's functions for handling NETCONF datastores\&. 


.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBncds_id\fP"

.PP
Datastore ID\&. Each datastore gets its ID after initialisation (\fBncds_init()\fP)\&. Only initialised datstores can be used to access configuration data\&. 
.PP
Definition at line 61 of file datastore\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBNC_DATASTORE\fP"

.PP
Enumeration of supported types of datastores defined by NETCONF\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINC_DATASTORE_NONE \fP\fP
value describing that no datastore was selected, (usage similar to NULL) 
.TP
\fB\fINC_DATASTORE_RUNNING \fP\fP
base NETCONF's datastore containing current device configuration 
.TP
\fB\fINC_DATASTORE_STARTUP \fP\fP
separated startup datastore as defined in Distinct Startup Capability 
.TP
\fB\fINC_DATASTORE_CANDIDATE \fP\fP
separated working datastore as defined in Candidate Configuration Capability 
.PP
Definition at line 232 of file netconf\&.h\&.
.SS "enum \fBNCDS_TYPE\fP"

.PP
Datastore implementation types provided by libnetconf\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fINCDS_TYPE_EMPTY \fP\fP
No datastore\&. For read-only devices\&.
.PP
\fBTodo\fP
.RS 4
Implement functions 
.RE
.PP

.TP
\fB\fINCDS_TYPE_FILE \fP\fP
Datastores implemented as files 
.PP
Definition at line 49 of file datastore\&.h\&.
.SH "Function Documentation"
.PP 
.SS "struct ncds_ds* ncds_new (\fBNCDS_TYPE\fPtype, const char *model_path, char *(*)(const char *model, const char *running, struct nc_err **e)get_state)\fC [read]\fP"

.PP
Create new datastore structure of the specified implementation type\&. \fBParameters:\fP
.RS 4
\fItype\fP Datastore implementation type for new datastore structure\&. 
.br
\fImodel_path\fP Path to the YIN configuration data model\&. 
.br
\fIget_state\fP Pointer to a callback function that returns serialized XML document containing state configuration data of the device\&. As parameters, it receives serialized configuration data model in YIN format and current content of the running datastore\&. If NULL is set, <get> operation is performed in the same way as <get-config>\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Prepared (not configured) datastore structure\&. To configure the structure, caller must use parameters setters of the specific datastore implementation type\&. Then, the datastore can be initiated (\fBncds_init()\fP) and used to access configuration data\&. 
.RE
.PP

.SS "int ncds_file_set_path (struct ncds_ds *datastore, const char *path)"

.PP
Assign path of the datastore file into the datastore structure\&. Checks if the file exist and is accessible for reading and writing\&. If the file does not exist it is created\&. File is opened and file descriptor is stored in the structure
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore structure to be configured\&. 
.br
\fIpath\fP File path to the file storing configuration datastores\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success -1 Invalid datastore -2 Invalid path ((does not exist && can not be created) || insufficient rights) 
.RE
.PP

.SS "\fBncds_id\fP ncds_init (struct ncds_ds *datastore)"

.PP
Activate datastore structure for use\&. The datastore configuration is checked and if everything is correct, datastore gets its unique ID to be used for datastore operations (\fBncds_apply_rpc()\fP)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore to be initiated\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Positive integer with datastore ID on success, negative value on error\&. -1 Invalid datastore -2 Type-specific initialization failed -3 Unsupported datastore type -4 Memory allocation problem 
.RE
.PP

.SS "void ncds_free (struct ncds_ds *datastore)"

.PP
Close specified datastore and free all resources\&. Equivalent function to \fBncds_free2()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore\fP Datastore to be closed\&. 
.RE
.PP

.SS "void ncds_free2 (\fBncds_id\fPdatastore_id)"

.PP
Close specified datastore and free all resources\&. Equivalent function to \fBncds_free()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdatastore_id\fP ID of the datastore to be closed\&. 
.RE
.PP

.SS "\fBnc_reply\fP* ncds_apply_rpc (\fBncds_id\fPid, const struct nc_session *session, const \fBnc_rpc\fP *rpc)"

.PP
Perform requested RPC operation on the datastore\&. \fBParameters:\fP
.RS 4
\fIid\fP Datastore ID\&. 
.br
\fIsession\fP NETCONF session (dummy session is acceptable) where the <rpc> came from\&. Capabilities checks are done according to this session\&. 
.br
\fIrpc\fP NETCONF <rpc> message specifying requested operation\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL in case of non NC_RPC_DATASTORE_* operation type, else <rpc-reply> with <ok>, <data> or <rpc-error> according to the type and the result of the requested operation\&. 
.RE
.PP

.SS "void ncds_break_locks (const struct nc_session *session)"

.PP
Remove all locks that is holding given session\&. \fBParameters:\fP
.RS 4
\fIsession\fP Session holding locks to remove 
.RE
.PP

.SS "char* ncds_get_model (\fBncds_id\fPid)"

.PP
Return serialized XML containing data model in YIN format\&. \fBParameters:\fP
.RS 4
\fIid\fP ID of datastore which data model we want
.RE
.PP
\fBReturns:\fP
.RS 4
String containing YIN model\&. Caller must free memory after use\&. 
.RE
.PP

.SS "const char* ncds_get_model_path (\fBncds_id\fPid)"

.PP
Return path to file containing datastore datamodel\&. \fBParameters:\fP
.RS 4
\fIid\fP ID of datastore which data model we want
.RE
.PP
\fBReturns:\fP
.RS 4
String containing path to file containing datastore datamodel\&. Caller must NOT free the memory\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libnetconf from the source code\&.
